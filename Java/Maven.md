# Maven
- [Maven](#maven)
- [Installation](#installation)
- [Use cases](#use-cases)
- [Lifecycle phases](#lifecycle-phases)
- [POM](#pom)
- [Parent POM](#parent-pom)
- [Troubleshoot](#troubleshoot)

# Installation
ref: https://maven.apache.org/install.html

# Use cases
- Common SDK: If several projects share some identical source code, can group this part of code as a SDK, and put it as a git repository in `pom.xml`. If the repository requires authentication, make sure your `${user}/.m2/settings.xml` contains the token.
  - Reduce repeated source code.
- Multi-module projects: You can divide the folders of a project as multiple modules. The project root directory would be a `aggregator POM` - the parent of the sub-modules. The sub-modules can depend on other modules, defined in `pom.xml`.
  - No need care about the build order of the modules.
  - Can build only a single module, without affecting other modules.
  - If different modules need different version of Java, consider [maven-toolchains-plugin](https://maven.apache.org/plugins/maven-toolchains-plugin/toolchains/jdk.html). For example, if in parent POM, maven compiler plugin is Java 1.7, but one module want to use Java 1.8, then parent POM need to use toolchain plugin at JDK 1.7, and that module POM need to use toolchain plugin at JDK 1.8.

# Lifecycle phases
Reference: https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html

**There are three built-in build lifecycles:**
- The `default` lifecycle handles your project deployment.
- The `clean` lifecycle handles project cleaning.
- The `site` lifecycle handles the creation of your project's web site. 

**Each of these build lifecycles is defined by a different list of build phases:**
- `default` (some common phases only)
  - `validate` - validate the project is correct and all necessary information is available
  - `compile` - compile the source code of the project
  - `test` - test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed
  - `package` - take the compiled code and package it in its distributable format, such as a JAR.
  - `verify` - run any checks on results of integration tests to ensure quality criteria are met
  - `install` - install the package into the local repository, for use as a dependency in other projects locally
  - `deploy` - done in the build environment, copies the final package to the remote repository for sharing with other developers and projects.
- `clean`
  - pre-clean
  - `clean` -	remove all files generated by the previous build
  - post-clean
- `site` (seldom use)

Note that the lifecycle phases are executed sequentially to complete a lifecycle. When a phase is given, Maven executes every phase in the sequence up to and including the one defined.

**A Build Phase is Made Up of Plugin Goals**

A plugin goal represents a specific task (finer than a build phase) which contributes to the building and managing of a project. It may be bound to zero or more build phases.

Furthermore, a build phase can also have zero or more goals bound to it. If a build phase has no goals bound to it, that build phase will not execute. But if it has one or more goals bound to it, it will execute all those goals.

Available plugins: https://maven.apache.org/plugins/index.html

For example, Apache Maven Compiler Plugin. The Compiler Plugin has two goals:
- `compiler:compile` is **bound** to the `compile` phase and is used to compile the main source files.
- `compiler:testCompile` is **bound** to the `test-compile` phase and is used to compile the test source files.

**Complete Flow**

If you run `mvn comile`, the complete flow actually is:
1. Decide that you are running the lifecycle `default`.
2. Execute the sequence of phases up to `compile`.
   1. Check all plugins and execute all goals that are bound to the `validate` phase.
   2. Check all plugins and execute all goals that are bound to the `initialize` phase.
   3. Check all plugins and execute all goals that are bound to the `generate-sources` phase.
   4. Check all plugins and execute all goals that are bound to the `process-sources` phase.
   5. Check all plugins and execute all goals that are bound to the `generate-resources` phase.
   6. Check all plugins and execute all goals that are bound to the `process-resources` phase.
   7. Check all plugins and execute all goals that are bound to the `compile` phase.

**Usual Command Line Calls**
```sh
# If you want the JAR
mvn package

mvn clean install -U
mvn clean install -Plocal -nsu -DskipTests -Dmaven.test.skip=true
```
- `-U` : force refresh and download the latest snapshot dependency versions
- `-nsu` : suppress SNAPSHOT updates
- `-P<arg>` : choose which profile to compile
- `-D<arg>` : define a system property

**Hints:**
- To speed up `mvn install`, avoid using `import xxx.*` in Java and delete unused `import`
- After `mvn install`, you can use `java -jar application/target/xxx.jar` to run the application.

# POM
Reference: https://maven.apache.org/guides/introduction/introduction-to-the-pom.html

```xml
<project>
  <modelVersion>4.0.0</modelVersion>   // must
  
  <parent>
    <groupId>com.mycompany</groupId>
    <artifactId>my-app-platform</artifactId>
    <version>1</version>
  </parent>

  <groupId>com.mycompany</groupId>     // must
  <artifactId>my-app</artifactId>      // must
  <version>1</version>                 // must

  <properties>
    <maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
    <junit-jupiter.version>5.9.1</junit-jupiter.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>${junit-jupiter.version}</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>${maven-compiler-plugin.version}</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
          <verbose>true</verbose>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```
- Project full name: `<groupId>:<artifactId>:<version>`
- Default repository: `https://repo.maven.apache.org/maven2`
- If have defined parent POM, will inherit its dependencies.

# Parent POM
Dependency: https://www.baeldung.com/maven-dependencymanagement-vs-dependencies-tags
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.hamcrest</groupId>
            <artifactId>hamcrest-core</artifactId>
            <version>2.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

// Child POM / Parent POM
<dependencies>
    <dependency>
        <groupId>org.hamcrest</groupId>
        <artifactId>hamcrest-core</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```
- `dependencyManagement` is just a declaration, and it does not really add a dependency. The declared dependencies in this section must be later used by the `dependencies` tag. It is just the `dependencies` tag that causes real dependency to happen.
- We define the version in the `dependencyManagement` tag, and then we can use the mentioned version without specifying it in the next `dependencies` tag.
- Use case: Imagine we have a big project which consists of different modules. Each module has its own dependencies, and each developer might use a different version for the used dependencies. Then it could lead to a mesh of different artifact versions, which can also cause difficult and hard-to-resolve conflicts. The easy solution for this problem is definitely using the `dependencyManagement` tag in the **parent POM file** and then using the `dependencies` in the childâ€™s POM files (sub-modules) and even the parent module itself (if applicable).
  - For my understanding, at least the parent POM file can be not committed.

Plugin: https://www.baeldung.com/maven-plugin-management
```xml
<pluginManagement>
    <plugins>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>build-helper-maven-plugin</artifactId>
            <version>3.3.0</version>
            <executions>
                <execution>
                    <id>add-resource</id>
                    <phase>generate-resources</phase>
                    <goals>
                        <goal>add-resource</goal>
                    </goals>
                    <configuration>
                        <resources>
                            <resource>
                                <directory>src/resources</directory>
                                <targetPath>json</targetPath>
                            </resource>
                        </resources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugin</groupId>
            <artifactId>maven-resources-plugin</artifactId>
            <version>3.3.1</version>
        </plugin>
   </plugins>
</pluginManagement>

// Child POM / Parent POM
<build>
    <plugins>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>build-helper-maven-plugin</artifactId>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-resources-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```
- Any child POMs will inherit the plugin executions simply by referencing the plugin in their plugin section. All we need to do is add the relevant groupId and artifactId, without having to duplicate the configuration or manage the version.
- `pluginManagement` is similar to `dependencyManagement`.

# Troubleshoot
- The http maven repository is blocked: https://stackoverflow.com/questions/67833372/getting-blocked-mirror-for-repositories-maven-error-even-after-adding-mirrors
- If some packages cannot found, but already `mvn package`, try to reload all maven projects.